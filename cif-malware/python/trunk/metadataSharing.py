#!/usr/bin/env python

#
# Generated Tue Jan  5 16:49:37 2010 by generateDS.py version 1.20c.
#

import sys
import getopt
from string import lower as str_lower
from xml.dom import minidom
from xml.dom import Node

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def format_string(self, input_data, input_name=''):
            return input_data
        def format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def format_boolean(self, input_data, input_name=''):
            return '%s' % input_data


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class malwareMetaData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, id=None, company=None, author=None, comment=None, timestamp=None, objects=None, objectProperties=None, relationships=None, fieldData=None):
        self.version = _cast(float, version)
        self.id = _cast(None, id)
        self.company = company
        self.author = author
        self.comment = comment
        self.timestamp = timestamp
        self.objects = objects
        self.objectProperties = objectProperties
        self.relationships = relationships
        self.fieldData = fieldData
    def factory(*args_, **kwargs_):
        if malwareMetaData.subclass:
            return malwareMetaData.subclass(*args_, **kwargs_)
        else:
            return malwareMetaData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_company(self): return self.company
    def set_company(self, company): self.company = company
    def get_author(self): return self.author
    def set_author(self, author): self.author = author
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def get_objects(self): return self.objects
    def set_objects(self, objects): self.objects = objects
    def get_objectProperties(self): return self.objectProperties
    def set_objectProperties(self, objectProperties): self.objectProperties = objectProperties
    def get_relationships(self): return self.relationships
    def set_relationships(self, relationships): self.relationships = relationships
    def get_fieldData(self): return self.fieldData
    def set_fieldData(self, fieldData): self.fieldData = fieldData
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='malwareMetaData', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='malwareMetaData')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='malwareMetaData'):
        outfile.write(' version="%s"' % self.format_float(self.version, input_name='version'))
        outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='malwareMetaData'):
        if self.company is not None:
            showIndent(outfile, level)
            outfile.write('<%scompany>%s</%scompany>\n' % (namespace_, self.format_string(quote_xml(self.company).encode(ExternalEncoding), input_name='company'), namespace_))
        if self.author is not None:
            showIndent(outfile, level)
            outfile.write('<%sauthor>%s</%sauthor>\n' % (namespace_, self.format_string(quote_xml(self.author).encode(ExternalEncoding), input_name='author'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('<%stimestamp>%s</%stimestamp>\n' % (namespace_, self.format_string(quote_xml(self.timestamp).encode(ExternalEncoding), input_name='timestamp'), namespace_))
        if self.objects:
            self.objects.export(outfile, level, namespace_, name_='objects')
        if self.objectProperties:
            self.objectProperties.export(outfile, level, namespace_, name_='objectProperties')
        if self.relationships:
            self.relationships.export(outfile, level, namespace_, name_='relationships')
        if self.fieldData:
            self.fieldData.export(outfile, level, namespace_, name_='fieldData')
    def hasContent_(self):
        if (
            self.company is not None or
            self.author is not None or
            self.comment is not None or
            self.timestamp is not None or
            self.objects is not None or
            self.objectProperties is not None or
            self.relationships is not None or
            self.fieldData is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='malwareMetaData'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = %f,\n' % (self.version,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.company is not None:
            showIndent(outfile, level)
            outfile.write('company=%s,\n' % quote_python(self.company).encode(ExternalEncoding))
        if self.author is not None:
            showIndent(outfile, level)
            outfile.write('author=%s,\n' % quote_python(self.author).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('timestamp=%s,\n' % quote_python(self.timestamp).encode(ExternalEncoding))
        if self.objects is not None:
            showIndent(outfile, level)
            outfile.write('objects=model_.objects(\n')
            self.objects.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.objectProperties is not None:
            showIndent(outfile, level)
            outfile.write('objectProperties=model_.objectProperties(\n')
            self.objectProperties.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.relationships is not None:
            showIndent(outfile, level)
            outfile.write('relationships=model_.relationships(\n')
            self.relationships.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fieldData is not None:
            showIndent(outfile, level)
            outfile.write('fieldData=model_.fieldData(\n')
            self.fieldData.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('version'):
            try:
                self.version = float(attrs.get('version').value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (version): %s' % exp)
        if attrs.get('id'):
            self.id = attrs.get('id').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'company':
            company_ = ''
            for text__content_ in child_.childNodes:
                company_ += text__content_.nodeValue
            self.company = company_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'author':
            author_ = ''
            for text__content_ in child_.childNodes:
                author_ += text__content_.nodeValue
            self.author = author_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'comment':
            comment_ = ''
            for text__content_ in child_.childNodes:
                comment_ += text__content_.nodeValue
            self.comment = comment_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'timestamp':
            timestamp_ = ''
            for text__content_ in child_.childNodes:
                timestamp_ += text__content_.nodeValue
            self.timestamp = timestamp_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'objects':
            obj_ = objects.factory()
            obj_.build(child_)
            self.set_objects(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'objectProperties':
            obj_ = objectProperties.factory()
            obj_.build(child_)
            self.set_objectProperties(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'relationships':
            obj_ = relationships.factory()
            obj_.build(child_)
            self.set_relationships(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'fieldData':
            obj_ = fieldData.factory()
            obj_.build(child_)
            self.set_fieldData(obj_)
# end class malwareMetaData


class objects(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, file=None, uri=None, domain=None, registry=None, ip=None, asn=None, entity=None, classification=None):
        if file is None:
            self.file = []
        else:
            self.file = file
        if uri is None:
            self.uri = []
        else:
            self.uri = uri
        if domain is None:
            self.domain = []
        else:
            self.domain = domain
        if registry is None:
            self.registry = []
        else:
            self.registry = registry
        if ip is None:
            self.ip = []
        else:
            self.ip = ip
        if asn is None:
            self.asn = []
        else:
            self.asn = asn
        if entity is None:
            self.entity = []
        else:
            self.entity = entity
        if classification is None:
            self.classification = []
        else:
            self.classification = classification
    def factory(*args_, **kwargs_):
        if objects.subclass:
            return objects.subclass(*args_, **kwargs_)
        else:
            return objects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_file(self): return self.file
    def set_file(self, file): self.file = file
    def add_file(self, value): self.file.append(value)
    def insert_file(self, index, value): self.file[index] = value
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def add_uri(self, value): self.uri.append(value)
    def insert_uri(self, index, value): self.uri[index] = value
    def get_domain(self): return self.domain
    def set_domain(self, domain): self.domain = domain
    def add_domain(self, value): self.domain.append(value)
    def insert_domain(self, index, value): self.domain[index] = value
    def get_registry(self): return self.registry
    def set_registry(self, registry): self.registry = registry
    def add_registry(self, value): self.registry.append(value)
    def insert_registry(self, index, value): self.registry[index] = value
    def get_ip(self): return self.ip
    def set_ip(self, ip): self.ip = ip
    def add_ip(self, value): self.ip.append(value)
    def insert_ip(self, index, value): self.ip[index] = value
    def get_asn(self): return self.asn
    def set_asn(self, asn): self.asn = asn
    def add_asn(self, value): self.asn.append(value)
    def insert_asn(self, index, value): self.asn[index] = value
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def add_entity(self, value): self.entity.append(value)
    def insert_entity(self, index, value): self.entity[index] = value
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def add_classification(self, value): self.classification.append(value)
    def insert_classification(self, index, value): self.classification[index] = value
    def export(self, outfile, level, namespace_='', name_='objects', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='objects')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='objects'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='objects'):
        for file_ in self.file:
            file_.export(outfile, level, namespace_, name_='file')
        for uri_ in self.uri:
            uri_.export(outfile, level, namespace_, name_='uri')
        for domain_ in self.domain:
            domain_.export(outfile, level, namespace_, name_='domain')
        for registry_ in self.registry:
            registry_.export(outfile, level, namespace_, name_='registry')
        for ip_ in self.ip:
            ip_.export(outfile, level, namespace_, name_='ip')
        for asn_ in self.asn:
            asn_.export(outfile, level, namespace_, name_='asn')
        for entity_ in self.entity:
            entity_.export(outfile, level, namespace_, name_='entity')
        for classification_ in self.classification:
            classification_.export(outfile, level, namespace_, name_='classification')
    def hasContent_(self):
        if (
            self.file or
            self.uri or
            self.domain or
            self.registry or
            self.ip or
            self.asn or
            self.entity or
            self.classification
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='objects'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('file=[\n')
        level += 1
        for file_ in self.file:
            showIndent(outfile, level)
            outfile.write('model_.fileObject(\n')
            file_.exportLiteral(outfile, level, name_='fileObject')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('uri=[\n')
        level += 1
        for uri_ in self.uri:
            showIndent(outfile, level)
            outfile.write('model_.uriObject(\n')
            uri_.exportLiteral(outfile, level, name_='uriObject')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('domain=[\n')
        level += 1
        for domain_ in self.domain:
            showIndent(outfile, level)
            outfile.write('model_.domainObject(\n')
            domain_.exportLiteral(outfile, level, name_='domainObject')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('registry=[\n')
        level += 1
        for registry_ in self.registry:
            showIndent(outfile, level)
            outfile.write('model_.registryObject(\n')
            registry_.exportLiteral(outfile, level, name_='registryObject')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ip=[\n')
        level += 1
        for ip_ in self.ip:
            showIndent(outfile, level)
            outfile.write('model_.IPObject(\n')
            ip_.exportLiteral(outfile, level, name_='IPObject')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('asn=[\n')
        level += 1
        for asn_ in self.asn:
            showIndent(outfile, level)
            outfile.write('model_.ASNObject(\n')
            asn_.exportLiteral(outfile, level, name_='ASNObject')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('entity=[\n')
        level += 1
        for entity_ in self.entity:
            showIndent(outfile, level)
            outfile.write('model_.entityObject(\n')
            entity_.exportLiteral(outfile, level, name_='entityObject')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('classification=[\n')
        level += 1
        for classification_ in self.classification:
            showIndent(outfile, level)
            outfile.write('model_.classificationObject(\n')
            classification_.exportLiteral(outfile, level, name_='classificationObject')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'file':
            obj_ = fileObject.factory()
            obj_.build(child_)
            self.file.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'uri':
            obj_ = uriObject.factory()
            obj_.build(child_)
            self.uri.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'domain':
            obj_ = domainObject.factory()
            obj_.build(child_)
            self.domain.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'registry':
            obj_ = registryObject.factory()
            obj_.build(child_)
            self.registry.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'ip':
            obj_ = IPObject.factory()
            obj_.build(child_)
            self.ip.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'asn':
            obj_ = ASNObject.factory()
            obj_.build(child_)
            self.asn.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'entity':
            obj_ = entityObject.factory()
            obj_.build(child_)
            self.entity.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'classification':
            obj_ = classificationObject.factory()
            obj_.build(child_)
            self.classification.append(obj_)
# end class objects


class objectProperties(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, objectProperty=None):
        if objectProperty is None:
            self.objectProperty = []
        else:
            self.objectProperty = objectProperty
    def factory(*args_, **kwargs_):
        if objectProperties.subclass:
            return objectProperties.subclass(*args_, **kwargs_)
        else:
            return objectProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_objectProperty(self): return self.objectProperty
    def set_objectProperty(self, objectProperty): self.objectProperty = objectProperty
    def add_objectProperty(self, value): self.objectProperty.append(value)
    def insert_objectProperty(self, index, value): self.objectProperty[index] = value
    def export(self, outfile, level, namespace_='', name_='objectProperties', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='objectProperties')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='objectProperties'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='objectProperties'):
        for objectProperty_ in self.objectProperty:
            objectProperty_.export(outfile, level, namespace_, name_='objectProperty')
    def hasContent_(self):
        if (
            self.objectProperty
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='objectProperties'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('objectProperty=[\n')
        level += 1
        for objectProperty_ in self.objectProperty:
            showIndent(outfile, level)
            outfile.write('model_.objectProperty(\n')
            objectProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'objectProperty':
            obj_ = objectProperty.factory()
            obj_.build(child_)
            self.objectProperty.append(obj_)
# end class objectProperties


class relationships(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, relationship=None):
        if relationship is None:
            self.relationship = []
        else:
            self.relationship = relationship
    def factory(*args_, **kwargs_):
        if relationships.subclass:
            return relationships.subclass(*args_, **kwargs_)
        else:
            return relationships(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_relationship(self): return self.relationship
    def set_relationship(self, relationship): self.relationship = relationship
    def add_relationship(self, value): self.relationship.append(value)
    def insert_relationship(self, index, value): self.relationship[index] = value
    def export(self, outfile, level, namespace_='', name_='relationships', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='relationships')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='relationships'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='relationships'):
        for relationship_ in self.relationship:
            relationship_.export(outfile, level, namespace_, name_='relationship')
    def hasContent_(self):
        if (
            self.relationship
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='relationships'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('relationship=[\n')
        level += 1
        for relationship_ in self.relationship:
            showIndent(outfile, level)
            outfile.write('model_.relationship(\n')
            relationship_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'relationship':
            obj_ = relationship.factory()
            obj_.build(child_)
            self.relationship.append(obj_)
# end class relationships


class fieldData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fieldDataEntry=None):
        if fieldDataEntry is None:
            self.fieldDataEntry = []
        else:
            self.fieldDataEntry = fieldDataEntry
    def factory(*args_, **kwargs_):
        if fieldData.subclass:
            return fieldData.subclass(*args_, **kwargs_)
        else:
            return fieldData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fieldDataEntry(self): return self.fieldDataEntry
    def set_fieldDataEntry(self, fieldDataEntry): self.fieldDataEntry = fieldDataEntry
    def add_fieldDataEntry(self, value): self.fieldDataEntry.append(value)
    def insert_fieldDataEntry(self, index, value): self.fieldDataEntry[index] = value
    def export(self, outfile, level, namespace_='', name_='fieldData', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fieldData')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='fieldData'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='fieldData'):
        for fieldDataEntry_ in self.fieldDataEntry:
            fieldDataEntry_.export(outfile, level, namespace_, name_='fieldDataEntry')
    def hasContent_(self):
        if (
            self.fieldDataEntry
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fieldData'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('fieldDataEntry=[\n')
        level += 1
        for fieldDataEntry_ in self.fieldDataEntry:
            showIndent(outfile, level)
            outfile.write('model_.fieldDataEntry(\n')
            fieldDataEntry_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'fieldDataEntry':
            obj_ = fieldDataEntry.factory()
            obj_.build(child_)
            self.fieldDataEntry.append(obj_)
# end class fieldData


class fileObject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, md5=None, sha1=None, sha256=None, sha512=None, size=None, crc32=None, fileType=None, extraHash=None):
        self.id = _cast(None, id)
        self.md5 = md5
        self.sha1 = sha1
        self.sha256 = sha256
        self.sha512 = sha512
        self.size = size
        self.crc32 = crc32
        if fileType is None:
            self.fileType = []
        else:
            self.fileType = fileType
        if extraHash is None:
            self.extraHash = []
        else:
            self.extraHash = extraHash
    def factory(*args_, **kwargs_):
        if fileObject.subclass:
            return fileObject.subclass(*args_, **kwargs_)
        else:
            return fileObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_md5(self): return self.md5
    def set_md5(self, md5): self.md5 = md5
    def get_sha1(self): return self.sha1
    def set_sha1(self, sha1): self.sha1 = sha1
    def get_sha256(self): return self.sha256
    def set_sha256(self, sha256): self.sha256 = sha256
    def get_sha512(self): return self.sha512
    def set_sha512(self, sha512): self.sha512 = sha512
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_crc32(self): return self.crc32
    def set_crc32(self, crc32): self.crc32 = crc32
    def get_fileType(self): return self.fileType
    def set_fileType(self, fileType): self.fileType = fileType
    def add_fileType(self, value): self.fileType.append(value)
    def insert_fileType(self, index, value): self.fileType[index] = value
    def get_extraHash(self): return self.extraHash
    def set_extraHash(self, extraHash): self.extraHash = extraHash
    def add_extraHash(self, value): self.extraHash.append(value)
    def insert_extraHash(self, index, value): self.extraHash[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='fileObject', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fileObject')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='fileObject'):
        outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='fileObject'):
        if self.md5 is not None:
            showIndent(outfile, level)
            outfile.write('<%smd5>%s</%smd5>\n' % (namespace_, self.format_string(quote_xml(self.md5).encode(ExternalEncoding), input_name='md5'), namespace_))
        if self.sha1 is not None:
            showIndent(outfile, level)
            outfile.write('<%ssha1>%s</%ssha1>\n' % (namespace_, self.format_string(quote_xml(self.sha1).encode(ExternalEncoding), input_name='sha1'), namespace_))
        if self.sha256 is not None:
            showIndent(outfile, level)
            outfile.write('<%ssha256>%s</%ssha256>\n' % (namespace_, self.format_string(quote_xml(self.sha256).encode(ExternalEncoding), input_name='sha256'), namespace_))
        if self.sha512 is not None:
            showIndent(outfile, level)
            outfile.write('<%ssha512>%s</%ssha512>\n' % (namespace_, self.format_string(quote_xml(self.sha512).encode(ExternalEncoding), input_name='sha512'), namespace_))
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('<%ssize>%s</%ssize>\n' % (namespace_, self.format_integer(self.size, input_name='size'), namespace_))
        if self.crc32 is not None:
            showIndent(outfile, level)
            outfile.write('<%scrc32>%s</%scrc32>\n' % (namespace_, self.format_string(quote_xml(self.crc32).encode(ExternalEncoding), input_name='crc32'), namespace_))
        for fileType_ in self.fileType:
            showIndent(outfile, level)
            outfile.write('<%sfileType>%s</%sfileType>\n' % (namespace_, self.format_string(quote_xml(fileType_).encode(ExternalEncoding), input_name='fileType'), namespace_))
        for extraHash_ in self.extraHash:
            extraHash_.export(outfile, level, namespace_, name_='extraHash')
    def hasContent_(self):
        if (
            self.md5 is not None or
            self.sha1 is not None or
            self.sha256 is not None or
            self.sha512 is not None or
            self.size is not None or
            self.crc32 is not None or
            self.fileType or
            self.extraHash
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileObject'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.md5 is not None:
            showIndent(outfile, level)
            outfile.write('md5=%s,\n' % quote_python(self.md5).encode(ExternalEncoding))
        if self.sha1 is not None:
            showIndent(outfile, level)
            outfile.write('sha1=%s,\n' % quote_python(self.sha1).encode(ExternalEncoding))
        if self.sha256 is not None:
            showIndent(outfile, level)
            outfile.write('sha256=%s,\n' % quote_python(self.sha256).encode(ExternalEncoding))
        if self.sha512 is not None:
            showIndent(outfile, level)
            outfile.write('sha512=%s,\n' % quote_python(self.sha512).encode(ExternalEncoding))
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
        if self.crc32 is not None:
            showIndent(outfile, level)
            outfile.write('crc32=%s,\n' % quote_python(self.crc32).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('fileType=[\n')
        level += 1
        for fileType_ in self.fileType:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(fileType_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('extraHash=[\n')
        level += 1
        for extraHash_ in self.extraHash:
            showIndent(outfile, level)
            outfile.write('model_.extraHash(\n')
            extraHash_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id = attrs.get('id').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'md5':
            md5_ = ''
            for text__content_ in child_.childNodes:
                md5_ += text__content_.nodeValue
            self.md5 = md5_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sha1':
            sha1_ = ''
            for text__content_ in child_.childNodes:
                sha1_ += text__content_.nodeValue
            self.sha1 = sha1_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sha256':
            sha256_ = ''
            for text__content_ in child_.childNodes:
                sha256_ += text__content_.nodeValue
            self.sha256 = sha256_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'sha512':
            sha512_ = ''
            for text__content_ in child_.childNodes:
                sha512_ += text__content_.nodeValue
            self.sha512 = sha512_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'size':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError, exp:
                    raise ValueError('requires integer (size): %s' % exp)
                self.size = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'crc32':
            crc32_ = ''
            for text__content_ in child_.childNodes:
                crc32_ += text__content_.nodeValue
            self.crc32 = crc32_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'fileType':
            fileType_ = ''
            for text__content_ in child_.childNodes:
                fileType_ += text__content_.nodeValue
            self.fileType.append(fileType_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'extraHash':
            obj_ = extraHash.factory()
            obj_.build(child_)
            self.extraHash.append(obj_)
# end class fileObject


class extraHash(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=''):
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if extraHash.subclass:
            return extraHash.subclass(*args_, **kwargs_)
        else:
            return extraHash(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='extraHash', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='extraHash')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='extraHash'):
        outfile.write(' type=%s' % (self.format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='extraHash'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='extraHash'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('type'):
            self.type_ = attrs.get('type').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class extraHash


class registryObject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, key=None, valueName=None):
        self.id = _cast(None, id)
        self.key = key
        self.valueName = valueName
    def factory(*args_, **kwargs_):
        if registryObject.subclass:
            return registryObject.subclass(*args_, **kwargs_)
        else:
            return registryObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_valueName(self): return self.valueName
    def set_valueName(self, valueName): self.valueName = valueName
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='registryObject', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='registryObject')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='registryObject'):
        outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='registryObject'):
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('<%skey>%s</%skey>\n' % (namespace_, self.format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_))
        if self.valueName is not None:
            showIndent(outfile, level)
            outfile.write('<%svalueName>%s</%svalueName>\n' % (namespace_, self.format_string(quote_xml(self.valueName).encode(ExternalEncoding), input_name='valueName'), namespace_))
    def hasContent_(self):
        if (
            self.key is not None or
            self.valueName is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='registryObject'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
        if self.valueName is not None:
            showIndent(outfile, level)
            outfile.write('valueName=%s,\n' % quote_python(self.valueName).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id = attrs.get('id').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'key':
            key_ = ''
            for text__content_ in child_.childNodes:
                key_ += text__content_.nodeValue
            self.key = key_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'valueName':
            valueName_ = ''
            for text__content_ in child_.childNodes:
                valueName_ += text__content_.nodeValue
            self.valueName = valueName_
# end class registryObject


class entityObject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None):
        self.id = _cast(None, id)
        self.name = name
    def factory(*args_, **kwargs_):
        if entityObject.subclass:
            return entityObject.subclass(*args_, **kwargs_)
        else:
            return entityObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='entityObject', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='entityObject')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='entityObject'):
        outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='entityObject'):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
    def hasContent_(self):
        if (
            self.name is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='entityObject'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id = attrs.get('id').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'name':
            name_ = ''
            for text__content_ in child_.childNodes:
                name_ += text__content_.nodeValue
            self.name = name_
# end class entityObject


class uriObject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, uriString=None, protocol=None, hostname=None, domain=None, port=None, path=None, ipProtocol=None):
        self.id = _cast(None, id)
        self.uriString = uriString
        self.protocol = protocol
        self.hostname = hostname
        self.domain = domain
        self.port = port
        self.path = path
        self.ipProtocol = ipProtocol
    def factory(*args_, **kwargs_):
        if uriObject.subclass:
            return uriObject.subclass(*args_, **kwargs_)
        else:
            return uriObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uriString(self): return self.uriString
    def set_uriString(self, uriString): self.uriString = uriString
    def validate_uriString(self, value):
        # validate type uriString
        pass
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_hostname(self): return self.hostname
    def set_hostname(self, hostname): self.hostname = hostname
    def get_domain(self): return self.domain
    def set_domain(self, domain): self.domain = domain
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def get_ipProtocol(self): return self.ipProtocol
    def set_ipProtocol(self, ipProtocol): self.ipProtocol = ipProtocol
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_NoQuestionMark(self, value):
        # Validate type NoQuestionMark, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='uriObject', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='uriObject')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='uriObject'):
        outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='uriObject'):
        if self.uriString is not None:
            showIndent(outfile, level)
            outfile.write('<%suriString>%s</%suriString>\n' % (namespace_, self.format_string(quote_xml(self.uriString).encode(ExternalEncoding), input_name='uriString'), namespace_))
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('<%sprotocol>%s</%sprotocol>\n' % (namespace_, self.format_string(quote_xml(self.protocol).encode(ExternalEncoding), input_name='protocol'), namespace_))
        if self.hostname is not None:
            showIndent(outfile, level)
            outfile.write('<%shostname>%s</%shostname>\n' % (namespace_, self.format_string(quote_xml(self.hostname).encode(ExternalEncoding), input_name='hostname'), namespace_))
        if self.domain is not None:
            showIndent(outfile, level)
            outfile.write('<%sdomain>%s</%sdomain>\n' % (namespace_, self.format_string(quote_xml(self.domain).encode(ExternalEncoding), input_name='domain'), namespace_))
        if self.port is not None:
            showIndent(outfile, level)
            outfile.write('<%sport>%s</%sport>\n' % (namespace_, self.format_integer(self.port, input_name='port'), namespace_))
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('<%spath>%s</%spath>\n' % (namespace_, self.format_string(quote_xml(self.path).encode(ExternalEncoding), input_name='path'), namespace_))
        if self.ipProtocol is not None:
            showIndent(outfile, level)
            outfile.write('<%sipProtocol>%s</%sipProtocol>\n' % (namespace_, self.format_string(quote_xml(self.ipProtocol).encode(ExternalEncoding), input_name='ipProtocol'), namespace_))
    def hasContent_(self):
        if (
            self.uriString is not None or
            self.protocol is not None or
            self.hostname is not None or
            self.domain is not None or
            self.port is not None or
            self.path is not None or
            self.ipProtocol is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='uriObject'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.uriString is not None:
            showIndent(outfile, level)
            outfile.write('uriString=%s,\n' % quote_python(self.uriString).encode(ExternalEncoding))
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=%s,\n' % quote_python(self.protocol).encode(ExternalEncoding))
        if self.hostname is not None:
            showIndent(outfile, level)
            outfile.write('hostname=%s,\n' % quote_python(self.hostname).encode(ExternalEncoding))
        if self.domain is not None:
            showIndent(outfile, level)
            outfile.write('domain=%s,\n' % quote_python(self.domain).encode(ExternalEncoding))
        if self.port is not None:
            showIndent(outfile, level)
            outfile.write('port=%d,\n' % self.port)
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('path=%s,\n' % quote_python(self.path).encode(ExternalEncoding))
        if self.ipProtocol is not None:
            showIndent(outfile, level)
            outfile.write('ipProtocol=%s,\n' % quote_python(self.ipProtocol).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id = attrs.get('id').value
            self.validate_NoQuestionMark(self.id)    # validate type NoQuestionMark
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'uriString':
            uriString_ = ''
            for text__content_ in child_.childNodes:
                uriString_ += text__content_.nodeValue
            self.uriString = uriString_
            self.validate_uriString(self.uriString)    # validate type uriString
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'protocol':
            protocol_ = ''
            for text__content_ in child_.childNodes:
                protocol_ += text__content_.nodeValue
            self.protocol = protocol_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'hostname':
            hostname_ = ''
            for text__content_ in child_.childNodes:
                hostname_ += text__content_.nodeValue
            self.hostname = hostname_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'domain':
            domain_ = ''
            for text__content_ in child_.childNodes:
                domain_ += text__content_.nodeValue
            self.domain = domain_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'port':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError, exp:
                    raise ValueError('requires integer (port): %s' % exp)
                self.port = ival_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'path':
            path_ = ''
            for text__content_ in child_.childNodes:
                path_ += text__content_.nodeValue
            self.path = path_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'ipProtocol':
            ipProtocol_ = ''
            for text__content_ in child_.childNodes:
                ipProtocol_ += text__content_.nodeValue
            self.ipProtocol = ipProtocol_
# end class uriObject


class IPObject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, startAddress=None, endAddress=None):
        self.id = _cast(None, id)
        self.startAddress = startAddress
        self.endAddress = endAddress
    def factory(*args_, **kwargs_):
        if IPObject.subclass:
            return IPObject.subclass(*args_, **kwargs_)
        else:
            return IPObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startAddress(self): return self.startAddress
    def set_startAddress(self, startAddress): self.startAddress = startAddress
    def get_endAddress(self): return self.endAddress
    def set_endAddress(self, endAddress): self.endAddress = endAddress
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_IPRange(self, value):
        # Validate type IPRange, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='IPObject', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='IPObject')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='IPObject'):
        outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IPObject'):
        if self.startAddress:
            self.startAddress.export(outfile, level, namespace_, name_='startAddress', )
        if self.endAddress:
            self.endAddress.export(outfile, level, namespace_, name_='endAddress', )
    def hasContent_(self):
        if (
            self.startAddress is not None or
            self.endAddress is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IPObject'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.startAddress is not None:
            showIndent(outfile, level)
            outfile.write('startAddress=model_.IPAddress(\n')
            self.startAddress.exportLiteral(outfile, level, name_='startAddress')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.endAddress is not None:
            showIndent(outfile, level)
            outfile.write('endAddress=model_.IPAddress(\n')
            self.endAddress.exportLiteral(outfile, level, name_='endAddress')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id = attrs.get('id').value
            self.validate_IPRange(self.id)    # validate type IPRange
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'startAddress':
            obj_ = IPAddress.factory()
            obj_.build(child_)
            self.set_startAddress(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'endAddress':
            obj_ = IPAddress.factory()
            obj_.build(child_)
            self.set_endAddress(obj_)
# end class IPObject


class IPAddress(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=''):
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if IPAddress.subclass:
            return IPAddress.subclass(*args_, **kwargs_)
        else:
            return IPAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_IPTypeEnum(self, value):
        # Validate type IPTypeEnum, a restriction on xs:string.
        pass
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='IPAddress', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='IPAddress')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='IPAddress'):
        outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IPAddress'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IPAddress'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('type'):
            self.type_ = attrs.get('type').value
            self.validate_IPTypeEnum(self.type_)    # validate type IPTypeEnum
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class IPAddress


class domainObject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, domain=None):
        self.id = _cast(None, id)
        self.domain = domain
    def factory(*args_, **kwargs_):
        if domainObject.subclass:
            return domainObject.subclass(*args_, **kwargs_)
        else:
            return domainObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domain(self): return self.domain
    def set_domain(self, domain): self.domain = domain
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='domainObject', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='domainObject')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='domainObject'):
        outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='domainObject'):
        if self.domain is not None:
            showIndent(outfile, level)
            outfile.write('<%sdomain>%s</%sdomain>\n' % (namespace_, self.format_string(quote_xml(self.domain).encode(ExternalEncoding), input_name='domain'), namespace_))
    def hasContent_(self):
        if (
            self.domain is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='domainObject'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.domain is not None:
            showIndent(outfile, level)
            outfile.write('domain=%s,\n' % quote_python(self.domain).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id = attrs.get('id').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'domain':
            domain_ = ''
            for text__content_ in child_.childNodes:
                domain_ += text__content_.nodeValue
            self.domain = domain_
# end class domainObject


class ASNObject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, as_number=None):
        self.id = _cast(int, id)
        self.as_number = as_number
    def factory(*args_, **kwargs_):
        if ASNObject.subclass:
            return ASNObject.subclass(*args_, **kwargs_)
        else:
            return ASNObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_as_number(self): return self.as_number
    def set_as_number(self, as_number): self.as_number = as_number
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='ASNObject', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ASNObject')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='ASNObject'):
        outfile.write(' id="%s"' % self.format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespace_='', name_='ASNObject'):
        if self.as_number is not None:
            showIndent(outfile, level)
            outfile.write('<%sas_number>%s</%sas_number>\n' % (namespace_, self.format_integer(self.as_number, input_name='as_number'), namespace_))
    def hasContent_(self):
        if (
            self.as_number is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ASNObject'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.as_number is not None:
            showIndent(outfile, level)
            outfile.write('as_number=%d,\n' % self.as_number)
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            try:
                self.id = int(attrs.get('id').value)
            except ValueError, exp:
                raise ValueError('Bad integer attribute (id): %s' % exp)
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'as-number':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    ival_ = int(sval_)
                except ValueError, exp:
                    raise ValueError('requires integer (as_number): %s' % exp)
                self.as_number = ival_
# end class ASNObject


class classificationObject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, id=None, classificationName=None, companyName=None, category=None, classificationDetails=None):
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.classificationName = classificationName
        self.companyName = companyName
        self.category = category
        self.classificationDetails = classificationDetails
    def factory(*args_, **kwargs_):
        if classificationObject.subclass:
            return classificationObject.subclass(*args_, **kwargs_)
        else:
            return classificationObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_classificationName(self): return self.classificationName
    def set_classificationName(self, classificationName): self.classificationName = classificationName
    def get_companyName(self): return self.companyName
    def set_companyName(self, companyName): self.companyName = companyName
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_classificationDetails(self): return self.classificationDetails
    def set_classificationDetails(self, classificationDetails): self.classificationDetails = classificationDetails
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_ClassificationTypeEnum(self, value):
        # Validate type ClassificationTypeEnum, a restriction on xs:string.
        pass
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='classificationObject', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='classificationObject')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='classificationObject'):
        outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='classificationObject'):
        if self.classificationName is not None:
            showIndent(outfile, level)
            outfile.write('<%sclassificationName>%s</%sclassificationName>\n' % (namespace_, self.format_string(quote_xml(self.classificationName).encode(ExternalEncoding), input_name='classificationName'), namespace_))
        if self.companyName is not None:
            showIndent(outfile, level)
            outfile.write('<%scompanyName>%s</%scompanyName>\n' % (namespace_, self.format_string(quote_xml(self.companyName).encode(ExternalEncoding), input_name='companyName'), namespace_))
        if self.category is not None:
            showIndent(outfile, level)
            outfile.write('<%scategory>%s</%scategory>\n' % (namespace_, self.format_string(quote_xml(self.category).encode(ExternalEncoding), input_name='category'), namespace_))
        if self.classificationDetails:
            self.classificationDetails.export(outfile, level, namespace_, name_='classificationDetails')
    def hasContent_(self):
        if (
            self.classificationName is not None or
            self.companyName is not None or
            self.category is not None or
            self.classificationDetails is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='classificationObject'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.classificationName is not None:
            showIndent(outfile, level)
            outfile.write('classificationName=%s,\n' % quote_python(self.classificationName).encode(ExternalEncoding))
        if self.companyName is not None:
            showIndent(outfile, level)
            outfile.write('companyName=%s,\n' % quote_python(self.companyName).encode(ExternalEncoding))
        if self.category is not None:
            showIndent(outfile, level)
            outfile.write('category=%s,\n' % quote_python(self.category).encode(ExternalEncoding))
        if self.classificationDetails is not None:
            showIndent(outfile, level)
            outfile.write('classificationDetails=model_.classificationDetails(\n')
            self.classificationDetails.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('type'):
            self.type_ = attrs.get('type').value
            self.validate_ClassificationTypeEnum(self.type_)    # validate type ClassificationTypeEnum
        if attrs.get('id'):
            self.id = attrs.get('id').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'classificationName':
            classificationName_ = ''
            for text__content_ in child_.childNodes:
                classificationName_ += text__content_.nodeValue
            self.classificationName = classificationName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'companyName':
            companyName_ = ''
            for text__content_ in child_.childNodes:
                companyName_ += text__content_.nodeValue
            self.companyName = companyName_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'category':
            category_ = ''
            for text__content_ in child_.childNodes:
                category_ += text__content_.nodeValue
            self.category = category_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'classificationDetails':
            obj_ = classificationDetails.factory()
            obj_.build(child_)
            self.set_classificationDetails(obj_)
# end class classificationObject


class classificationDetails(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, definitionVersion=None, detectionAddedTimeStamp=None, detectionShippedTimeStamp=None, product=None, productVersion=None):
        self.definitionVersion = definitionVersion
        self.detectionAddedTimeStamp = detectionAddedTimeStamp
        self.detectionShippedTimeStamp = detectionShippedTimeStamp
        self.product = product
        self.productVersion = productVersion
    def factory(*args_, **kwargs_):
        if classificationDetails.subclass:
            return classificationDetails.subclass(*args_, **kwargs_)
        else:
            return classificationDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_definitionVersion(self): return self.definitionVersion
    def set_definitionVersion(self, definitionVersion): self.definitionVersion = definitionVersion
    def get_detectionAddedTimeStamp(self): return self.detectionAddedTimeStamp
    def set_detectionAddedTimeStamp(self, detectionAddedTimeStamp): self.detectionAddedTimeStamp = detectionAddedTimeStamp
    def get_detectionShippedTimeStamp(self): return self.detectionShippedTimeStamp
    def set_detectionShippedTimeStamp(self, detectionShippedTimeStamp): self.detectionShippedTimeStamp = detectionShippedTimeStamp
    def get_product(self): return self.product
    def set_product(self, product): self.product = product
    def get_productVersion(self): return self.productVersion
    def set_productVersion(self, productVersion): self.productVersion = productVersion
    def export(self, outfile, level, namespace_='', name_='classificationDetails', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='classificationDetails')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='classificationDetails'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='classificationDetails'):
        if self.definitionVersion is not None:
            showIndent(outfile, level)
            outfile.write('<%sdefinitionVersion>%s</%sdefinitionVersion>\n' % (namespace_, self.format_string(quote_xml(self.definitionVersion).encode(ExternalEncoding), input_name='definitionVersion'), namespace_))
        if self.detectionAddedTimeStamp is not None:
            showIndent(outfile, level)
            outfile.write('<%sdetectionAddedTimeStamp>%s</%sdetectionAddedTimeStamp>\n' % (namespace_, self.format_string(quote_xml(self.detectionAddedTimeStamp).encode(ExternalEncoding), input_name='detectionAddedTimeStamp'), namespace_))
        if self.detectionShippedTimeStamp is not None:
            showIndent(outfile, level)
            outfile.write('<%sdetectionShippedTimeStamp>%s</%sdetectionShippedTimeStamp>\n' % (namespace_, self.format_string(quote_xml(self.detectionShippedTimeStamp).encode(ExternalEncoding), input_name='detectionShippedTimeStamp'), namespace_))
        if self.product is not None:
            showIndent(outfile, level)
            outfile.write('<%sproduct>%s</%sproduct>\n' % (namespace_, self.format_string(quote_xml(self.product).encode(ExternalEncoding), input_name='product'), namespace_))
        if self.productVersion is not None:
            showIndent(outfile, level)
            outfile.write('<%sproductVersion>%s</%sproductVersion>\n' % (namespace_, self.format_string(quote_xml(self.productVersion).encode(ExternalEncoding), input_name='productVersion'), namespace_))
    def hasContent_(self):
        if (
            self.definitionVersion is not None or
            self.detectionAddedTimeStamp is not None or
            self.detectionShippedTimeStamp is not None or
            self.product is not None or
            self.productVersion is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='classificationDetails'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.definitionVersion is not None:
            showIndent(outfile, level)
            outfile.write('definitionVersion=%s,\n' % quote_python(self.definitionVersion).encode(ExternalEncoding))
        if self.detectionAddedTimeStamp is not None:
            showIndent(outfile, level)
            outfile.write('detectionAddedTimeStamp=%s,\n' % quote_python(self.detectionAddedTimeStamp).encode(ExternalEncoding))
        if self.detectionShippedTimeStamp is not None:
            showIndent(outfile, level)
            outfile.write('detectionShippedTimeStamp=%s,\n' % quote_python(self.detectionShippedTimeStamp).encode(ExternalEncoding))
        if self.product is not None:
            showIndent(outfile, level)
            outfile.write('product=%s,\n' % quote_python(self.product).encode(ExternalEncoding))
        if self.productVersion is not None:
            showIndent(outfile, level)
            outfile.write('productVersion=%s,\n' % quote_python(self.productVersion).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'definitionVersion':
            definitionVersion_ = ''
            for text__content_ in child_.childNodes:
                definitionVersion_ += text__content_.nodeValue
            self.definitionVersion = definitionVersion_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'detectionAddedTimeStamp':
            detectionAddedTimeStamp_ = ''
            for text__content_ in child_.childNodes:
                detectionAddedTimeStamp_ += text__content_.nodeValue
            self.detectionAddedTimeStamp = detectionAddedTimeStamp_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'detectionShippedTimeStamp':
            detectionShippedTimeStamp_ = ''
            for text__content_ in child_.childNodes:
                detectionShippedTimeStamp_ += text__content_.nodeValue
            self.detectionShippedTimeStamp = detectionShippedTimeStamp_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'product':
            product_ = ''
            for text__content_ in child_.childNodes:
                product_ += text__content_.nodeValue
            self.product = product_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'productVersion':
            productVersion_ = ''
            for text__content_ in child_.childNodes:
                productVersion_ += text__content_.nodeValue
            self.productVersion = productVersion_
# end class classificationDetails


class fieldDataEntry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, references=None, startDate=None, endDate=None, firstSeenDate=None, origin=None, commonality=None, volume=None, importance=None, location=None):
        self.references = references
        self.startDate = startDate
        self.endDate = endDate
        self.firstSeenDate = firstSeenDate
        self.origin = origin
        self.commonality = commonality
        if volume is None:
            self.volume = []
        else:
            self.volume = volume
        self.importance = importance
        self.location = location
    def factory(*args_, **kwargs_):
        if fieldDataEntry.subclass:
            return fieldDataEntry.subclass(*args_, **kwargs_)
        else:
            return fieldDataEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_references(self): return self.references
    def set_references(self, references): self.references = references
    def get_startDate(self): return self.startDate
    def set_startDate(self, startDate): self.startDate = startDate
    def get_endDate(self): return self.endDate
    def set_endDate(self, endDate): self.endDate = endDate
    def get_firstSeenDate(self): return self.firstSeenDate
    def set_firstSeenDate(self, firstSeenDate): self.firstSeenDate = firstSeenDate
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def validate_origin(self, value):
        # validate type origin
        pass
    def get_commonality(self): return self.commonality
    def set_commonality(self, commonality): self.commonality = commonality
    def validate_commonality(self, value):
        # validate type commonality
        pass
    def get_volume(self): return self.volume
    def set_volume(self, volume): self.volume = volume
    def add_volume(self, value): self.volume.append(value)
    def insert_volume(self, index, value): self.volume[index] = value
    def get_importance(self): return self.importance
    def set_importance(self, importance): self.importance = importance
    def validate_importance(self, value):
        # validate type importance
        pass
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def export(self, outfile, level, namespace_='', name_='fieldDataEntry', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fieldDataEntry')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='fieldDataEntry'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='fieldDataEntry'):
        if self.references:
            self.references.export(outfile, level, namespace_, name_='references', )
        if self.startDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sstartDate>%s</%sstartDate>\n' % (namespace_, self.format_string(quote_xml(self.startDate).encode(ExternalEncoding), input_name='startDate'), namespace_))
        if self.endDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sendDate>%s</%sendDate>\n' % (namespace_, self.format_string(quote_xml(self.endDate).encode(ExternalEncoding), input_name='endDate'), namespace_))
        if self.firstSeenDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sfirstSeenDate>%s</%sfirstSeenDate>\n' % (namespace_, self.format_string(quote_xml(self.firstSeenDate).encode(ExternalEncoding), input_name='firstSeenDate'), namespace_))
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('<%sorigin>%s</%sorigin>\n' % (namespace_, self.format_string(quote_xml(self.origin).encode(ExternalEncoding), input_name='origin'), namespace_))
        if self.commonality is not None:
            showIndent(outfile, level)
            outfile.write('<%scommonality>%s</%scommonality>\n' % (namespace_, self.format_string(quote_xml(self.commonality).encode(ExternalEncoding), input_name='commonality'), namespace_))
        for volume_ in self.volume:
            volume_.export(outfile, level, namespace_, name_='volume')
        if self.importance is not None:
            showIndent(outfile, level)
            outfile.write('<%simportance>%s</%simportance>\n' % (namespace_, self.format_string(quote_xml(self.importance).encode(ExternalEncoding), input_name='importance'), namespace_))
        if self.location:
            self.location.export(outfile, level, namespace_, name_='location')
    def hasContent_(self):
        if (
            self.references is not None or
            self.startDate is not None or
            self.endDate is not None or
            self.firstSeenDate is not None or
            self.origin is not None or
            self.commonality is not None or
            self.volume or
            self.importance is not None or
            self.location is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fieldDataEntry'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.references is not None:
            showIndent(outfile, level)
            outfile.write('references=model_.references(\n')
            self.references.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.startDate is not None:
            showIndent(outfile, level)
            outfile.write('startDate=%s,\n' % quote_python(self.startDate).encode(ExternalEncoding))
        if self.endDate is not None:
            showIndent(outfile, level)
            outfile.write('endDate=%s,\n' % quote_python(self.endDate).encode(ExternalEncoding))
        if self.firstSeenDate is not None:
            showIndent(outfile, level)
            outfile.write('firstSeenDate=%s,\n' % quote_python(self.firstSeenDate).encode(ExternalEncoding))
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin=%s,\n' % quote_python(self.origin).encode(ExternalEncoding))
        if self.commonality is not None:
            showIndent(outfile, level)
            outfile.write('commonality=%d,\n' % self.commonality)
        showIndent(outfile, level)
        outfile.write('volume=[\n')
        level += 1
        for volume_ in self.volume:
            showIndent(outfile, level)
            outfile.write('model_.volume(\n')
            volume_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.importance is not None:
            showIndent(outfile, level)
            outfile.write('importance=%d,\n' % self.importance)
        if self.location is not None:
            showIndent(outfile, level)
            outfile.write('location=model_.location(\n')
            self.location.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'references':
            obj_ = references.factory()
            obj_.build(child_)
            self.set_references(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'startDate':
            startDate_ = ''
            for text__content_ in child_.childNodes:
                startDate_ += text__content_.nodeValue
            self.startDate = startDate_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'endDate':
            endDate_ = ''
            for text__content_ in child_.childNodes:
                endDate_ += text__content_.nodeValue
            self.endDate = endDate_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'firstSeenDate':
            firstSeenDate_ = ''
            for text__content_ in child_.childNodes:
                firstSeenDate_ += text__content_.nodeValue
            self.firstSeenDate = firstSeenDate_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'origin':
            origin_ = ''
            for text__content_ in child_.childNodes:
                origin_ += text__content_.nodeValue
            self.origin = origin_
            self.validate_origin(self.origin)    # validate type origin
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'commonality':
            commonality_ = ''
            for text__content_ in child_.childNodes:
                commonality_ += text__content_.nodeValue
            self.commonality = commonality_
            self.validate_commonality(self.commonality)    # validate type commonality
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'volume':
            obj_ = volume.factory()
            obj_.build(child_)
            self.volume.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'importance':
            importance_ = ''
            for text__content_ in child_.childNodes:
                importance_ += text__content_.nodeValue
            self.importance = importance_
            self.validate_importance(self.importance)    # validate type importance
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'location':
            obj_ = location.factory()
            obj_.build(child_)
            self.set_location(obj_)
# end class fieldDataEntry


class references(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ref=None):
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
    def factory(*args_, **kwargs_):
        if references.subclass:
            return references.subclass(*args_, **kwargs_)
        else:
            return references(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def add_ref(self, value): self.ref.append(value)
    def insert_ref(self, index, value): self.ref[index] = value
    def export(self, outfile, level, namespace_='', name_='references', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='references')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='references'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='references'):
        for ref_ in self.ref:
            ref_.export(outfile, level, namespace_, name_='ref')
    def hasContent_(self):
        if (
            self.ref
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='references'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ref=[\n')
        level += 1
        for ref_ in self.ref:
            showIndent(outfile, level)
            outfile.write('model_.reference(\n')
            ref_.exportLiteral(outfile, level, name_='reference')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'ref':
            obj_ = reference.factory()
            obj_.build(child_)
            self.ref.append(obj_)
# end class references


class volume(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, units=None, valueOf_=''):
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if volume.subclass:
            return volume.subclass(*args_, **kwargs_)
        else:
            return volume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def validate_VolumeUnitsEnum(self, value):
        # Validate type VolumeUnitsEnum, a restriction on xs:string.
        pass
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='volume', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='volume')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='volume'):
        outfile.write(' units=%s' % (quote_attrib(self.units), ))
    def exportChildren(self, outfile, level, namespace_='', name_='volume'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='volume'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.units is not None:
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('units'):
            self.units = attrs.get('units').value
            self.validate_VolumeUnitsEnum(self.units)    # validate type VolumeUnitsEnum
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class volume


class location(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=''):
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if location.subclass:
            return location.subclass(*args_, **kwargs_)
        else:
            return location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_LocationTypeEnum(self, value):
        # Validate type LocationTypeEnum, a restriction on xs:string.
        pass
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='location', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='location')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='location'):
        if self.type_ is not None:
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='', name_='location'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='location'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('type'):
            self.type_ = attrs.get('type').value
            self.validate_LocationTypeEnum(self.type_)    # validate type LocationTypeEnum
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class location


class reference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=''):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if reference.subclass:
            return reference.subclass(*args_, **kwargs_)
        else:
            return reference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='reference', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='reference')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='reference'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='reference'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='reference'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class reference


class property(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=''):
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if property.subclass:
            return property.subclass(*args_, **kwargs_)
        else:
            return property(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_PropertyTypeEnum(self, value):
        # Validate type PropertyTypeEnum, a restriction on xs:string.
        pass
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='property', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='property')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='property'):
        outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='', name_='property'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='property'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('type'):
            self.type_ = attrs.get('type').value
            self.validate_PropertyTypeEnum(self.type_)    # validate type PropertyTypeEnum
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class property


class objectProperty(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, references=None, timestamp=None, property=None):
        self.id = _cast(None, id)
        self.references = references
        self.timestamp = timestamp
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if objectProperty.subclass:
            return objectProperty.subclass(*args_, **kwargs_)
        else:
            return objectProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_references(self): return self.references
    def set_references(self, references): self.references = references
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property(self, index, value): self.property[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='objectProperty', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='objectProperty')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='objectProperty'):
        if self.id is not None:
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='objectProperty'):
        if self.references:
            self.references.export(outfile, level, namespace_, name_='references', )
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('<%stimestamp>%s</%stimestamp>\n' % (namespace_, self.format_string(quote_xml(self.timestamp).encode(ExternalEncoding), input_name='timestamp'), namespace_))
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property')
    def hasContent_(self):
        if (
            self.references is not None or
            self.timestamp is not None or
            self.property
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='objectProperty'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.references is not None:
            showIndent(outfile, level)
            outfile.write('references=model_.references(\n')
            self.references.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('timestamp=%s,\n' % quote_python(self.timestamp).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('property=[\n')
        level += 1
        for property_ in self.property:
            showIndent(outfile, level)
            outfile.write('model_.property(\n')
            property_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id = attrs.get('id').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'references':
            obj_ = references.factory()
            obj_.build(child_)
            self.set_references(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'timestamp':
            timestamp_ = ''
            for text__content_ in child_.childNodes:
                timestamp_ += text__content_.nodeValue
            self.timestamp = timestamp_
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'property':
            obj_ = property.factory()
            obj_.build(child_)
            self.property.append(obj_)
# end class objectProperty


class relationship(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, id=None, source=None, target=None, timestamp=None):
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.source = source
        self.target = target
        self.timestamp = timestamp
    def factory(*args_, **kwargs_):
        if relationship.subclass:
            return relationship.subclass(*args_, **kwargs_)
        else:
            return relationship(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_RelationshipTypeEnum(self, value):
        # Validate type RelationshipTypeEnum, a restriction on xs:string.
        pass
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='relationship', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='relationship')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='relationship'):
        outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.id is not None:
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='relationship'):
        if self.source:
            self.source.export(outfile, level, namespace_, name_='source', )
        if self.target:
            self.target.export(outfile, level, namespace_, name_='target', )
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('<%stimestamp>%s</%stimestamp>\n' % (namespace_, self.format_string(quote_xml(self.timestamp).encode(ExternalEncoding), input_name='timestamp'), namespace_))
    def hasContent_(self):
        if (
            self.source is not None or
            self.target is not None or
            self.timestamp is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='relationship'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.source(\n')
            self.source.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.target is not None:
            showIndent(outfile, level)
            outfile.write('target=model_.target(\n')
            self.target.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('timestamp=%s,\n' % quote_python(self.timestamp).encode(ExternalEncoding))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('type'):
            self.type_ = attrs.get('type').value
            self.validate_RelationshipTypeEnum(self.type_)    # validate type RelationshipTypeEnum
        if attrs.get('id'):
            self.id = attrs.get('id').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'source':
            obj_ = source.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'target':
            obj_ = target.factory()
            obj_.build(child_)
            self.set_target(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'timestamp':
            timestamp_ = ''
            for text__content_ in child_.childNodes:
                timestamp_ += text__content_.nodeValue
            self.timestamp = timestamp_
# end class relationship


class source(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ref=None):
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
    def factory(*args_, **kwargs_):
        if source.subclass:
            return source.subclass(*args_, **kwargs_)
        else:
            return source(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def add_ref(self, value): self.ref.append(value)
    def insert_ref(self, index, value): self.ref[index] = value
    def export(self, outfile, level, namespace_='', name_='source', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='source')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='source'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='source'):
        for ref_ in self.ref:
            ref_.export(outfile, level, namespace_, name_='ref')
    def hasContent_(self):
        if (
            self.ref
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='source'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ref=[\n')
        level += 1
        for ref_ in self.ref:
            showIndent(outfile, level)
            outfile.write('model_.reference(\n')
            ref_.exportLiteral(outfile, level, name_='reference')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'ref':
            obj_ = reference.factory()
            obj_.build(child_)
            self.ref.append(obj_)
# end class source


class target(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ref=None):
        if ref is None:
            self.ref = []
        else:
            self.ref = ref
    def factory(*args_, **kwargs_):
        if target.subclass:
            return target.subclass(*args_, **kwargs_)
        else:
            return target(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def add_ref(self, value): self.ref.append(value)
    def insert_ref(self, index, value): self.ref[index] = value
    def export(self, outfile, level, namespace_='', name_='target', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='target')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='target'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='target'):
        for ref_ in self.ref:
            ref_.export(outfile, level, namespace_, name_='ref')
    def hasContent_(self):
        if (
            self.ref
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='target'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ref=[\n')
        level += 1
        for ref_ in self.ref:
            showIndent(outfile, level)
            outfile.write('model_.reference(\n')
            ref_.exportLiteral(outfile, level, name_='reference')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'ref':
            obj_ = reference.factory()
            obj_.build(child_)
            self.ref.append(obj_)
# end class target


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = malwareMetaData.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="malwareMetaData", 
        namespacedef_='')
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = malwareMetaData.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="malwareMetaData",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = malwareMetaData.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from metadataSharing import *\n\n')
    sys.stdout.write('import metadataSharing as model_\n\n')
    sys.stdout.write('rootObj = model_.malwareMetaData(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_="malwareMetaData")
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

