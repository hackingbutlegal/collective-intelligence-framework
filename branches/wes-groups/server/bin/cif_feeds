#!/usr/bin/perl

use warnings;
use strict;

# fix lib paths, some may be relative
BEGIN {
    require File::Spec;
    my @libs = ("lib", "local/lib");
    my $bin_path;

    for my $lib (@libs) {
        unless ( File::Spec->file_name_is_absolute($lib) ) {
            unless ($bin_path) {
                if ( File::Spec->file_name_is_absolute(__FILE__) ) {
                    $bin_path = ( File::Spec->splitpath(__FILE__) )[1];
                }
                else {
                    require FindBin;
                    no warnings "once";
                    $bin_path = $FindBin::Bin;
                }
            }
            $lib = File::Spec->catfile( $bin_path, File::Spec->updir, $lib );
        }
        unshift @INC, $lib;
    }

}

use Getopt::Std;
use DateTime;
use JSON;
use Digest::SHA1 qw/sha1_hex/;
use MIME::Base64;
use Config::Simple;
use Data::Dumper;
use Compress::Zlib;
use CIF::Archive;
use CIF::Archive::DataType::Plugin::Feed;
use CIF::Utils ':all';
use threads;

my %opts;
getopts('D:ht:S:c:df:s:r:m:F:C:T:',\%opts);

my $severity    = $opts{'s'};
my $confidence  = $opts{'c'};
my $restriction = $opts{'r'};
my $maxdays     = $opts{'D'} || 3;
my $debug       = $opts{'d'};
my $config      = $opts{'C'} || $ENV{'HOME'}.'/.cif';
my $last_feeds  = $opts{'F'} || 5;
my $mutex       = $opts{'L'} || '/tmp/cif_feeds.lock';
my $specific    = $opts{'S'};
my $throttle    = $opts{'T'} || 'low';
$opts{'t'} = 1 if($specific);
 

my $cfg = Config::Simple->new($config) || die('missing config file');
my $maxrecords  = $opts{'m'} || $cfg->param(-block => 'cif_feeds')->{'maxrecords'} || 50000;
my @plugs = CIF::Archive->plugins('datatype');
my $sf = $cfg->param(-block  => 'cif_feeds')->{'severity_feeds'};
my $cf = $cfg->param(-block => 'cif_feeds')->{'confidence_feeds'};
my $rf = $cfg->param(-block => 'cif_feeds')->{'restriction_feeds'};
my $disabled_feeds = $cfg->param(-block => 'cif_feeds')->{'disabled_feeds'};

$SIG{'INT'} = 'cleanup';
$SIG{__DIE__} = 'cleanup';

sub cleanup {
    my $msg = shift;
    if($msg){   
        print $msg."\n";
    } else {
        print "\n\nCaught Interrupt (^C), Aborting\n";
    }
    remove_lock();
    exit(1);
}

sub remove_lock {
    system('rm '.$mutex);
}

if(-e $mutex && !$specific){
    print 'already running, mutex found: '.$mutex."\n" if($debug);
    exit(-1);
}
my $ret = system('touch '.$mutex);
unless(defined($ret) && $ret == 0){
    die($!);
}

my @severity_feeds;
my @confidence_feeds;
my @restriction_feeds;
if($severity){
    push(@severity_feeds,$severity);
} elsif($sf) {
    if(ref($sf) eq 'ARRAY'){
        @severity_feeds = @{$sf};
    } else {
        push(@severity_feeds,$sf);
    }
} else {
    push(@severity_feeds,'high');
}

if($confidence){
    push(@confidence_feeds,$confidence);
} elsif($cf) {
    if(ref($cf) eq 'ARRAY'){
        @confidence_feeds = @{$cf};
    } else {
        push(@confidence_feeds,$cf);
    }
} else {
    push(@confidence_feeds,'85');
}

if($restriction){
    push(@restriction_feeds,$restriction);
} elsif($rf){
    if(ref($rf) eq 'ARRAY'){
        @restriction_feeds = @{$rf};
    } else {
        push(@restriction_feeds,$rf);
    }
} else {
    push(@restriction_feeds,'private');
}

@plugs = grep(!/(Feed|Analytic)/,@plugs);
if($disabled_feeds){    
    if(ref($disabled_feeds) eq 'ARRAY'){
        foreach(@{$disabled_feeds}){
            my $f = ucfirst($_);
            @plugs = grep(!/$f$/,@plugs);
        }
    } else {
        my $f = ucfirst($disabled_feeds);
        @plugs = grep(!/$f$/,@plugs);
    }
}
if($specific){
    $specific = ucfirst($specific);
    @plugs = grep(/$specific$/,@plugs);
}
my $restriction_map = $cfg->param(-block => 'restrictions');
if($opts{'h'}){
    print usage();
    remove_lock();
    exit(0);
}

my %map;
my @feeds;

## TODO -- re-write this 
sub usage {
    my $usage_feeds = join("\n\t",@feeds);
    return <<EOF;
Usage: perl $0 -s medium -c 95
    -h  --help:         this meessage

    -s  --severity:     feed severity (low|medium|high), default: $severity
    -c  --confidence:   minimal confidence (0.00 - 100.0), default: $confidence
    -r  --restriction:  feed restriction (default|public|need-to-know|private), default: $restriction
    -m  --maxrecords:   max feed records, default: $maxrecords
    -D  --maxdays:      max days to go back in feed search, default: $maxdays
    -T  --throttle:     throttle the feed generation (low|medium|high), default: $throttle
    -S  --specific:     generate a specific feed (eg: infrastructure, domain, etc)
    -C  --config:       specify an alternate config location, default $config
    -d  --debug
    -M  --mutex:        specify a different lockfile location, default: $mutex
    -L  --lastfeeds:    specify how many feeds to keep in the archive, default: $last_feeds

Examples:

    cif_feeds -d -S infrastructure
    cif_feeds -c 40
    cif_feeds -c 40 -s medium
    cif_feeds -c 95 -s high -T high

EOF
}

my $dt = DateTime->from_epoch(epoch => time());
$dt = $dt->ymd().'T'.$dt->hms().'Z';

my $threads = $opts{'t'} || CIF::Utils::throttle($throttle);
my $batches = CIF::Utils::split_batches($threads,\@plugs);
if(scalar @{$batches} == 1){
    process(@{$batches});
} else {
    foreach (@{$batches}){
        my $t = threads->create('process',$_);
    }
    while(threads->list()){
        my @joinable = threads->list(threads::joinable);
        unless($#joinable > -1){
            sleep(1);
            next();
        }
        foreach(@joinable){
            $_->join();
        }
    }
}

sub process {
    my $p = shift;

    foreach (@{$p}){
        generate_feed($_);
    }
}    

sub generate_feed {
    my $plug = shift;

    my $start = time();

    _debug('processing: '.$_);

    my $detecttime = DateTime->from_epoch(epoch => (time() - (84600 * $maxdays)));
    _profile('searching',$start);
    foreach my $r (@restriction_feeds){
    foreach my $sev (@severity_feeds){
        foreach my $conf (@confidence_feeds){
            my $ret = $_->feed({
                severity    => $sev,
                restriction => $r,
                confidence  => $conf,
                detecttime  => $detecttime,
                maxrecords  => 50000,
            });
            unless($ret){
                _debug('no records');
                next();
            }
            my @feeds = @$ret;
            _profile('mapping',$start);
            my @types = map { $_->{'feed'}->{'title'} } @feeds;
            foreach my $f (@feeds){
                my @recs = @{$f->{'feed'}->{'entry'}};
                _debug('records: '.@recs);
                next unless(defined($#recs));
                my $loc_restriction = $r;
                if($recs[0] && keys %$restriction_map){
                    $loc_restriction = $restriction_map->{$r};
                    foreach my $rec (@recs){
                        my ($x,$alt_r);
                        if(exists($rec->{'Incident'}->{'restriction'})){
                            $x = $rec->{'Incident'}->{'restriction'};
                        }
                        if(exists($rec->{'Incident'}->{'AlternativeID'}->{'IncidentID'}->{'restriction'})){
                            $alt_r = $rec->{'Incident'}->{'AlternativeID'}->{'IncidentID'}->{'restriction'};
                        }
                        if($x && exists($restriction_map->{$x})){
                            $x = $restriction_map->{$x};
                        }
                        if($alt_r && exists($restriction_map->{$alt_r})){
                            $alt_r = $restriction_map->{$alt_r};
                        }
                        $rec->{'Incident'}->{'restriction'} = $x if($x);
                        if($alt_r){
                            $rec->{'Incident'}->{'AlternativeID'}->{'IncidentID'}->{'restriction'} = $alt_r if($alt_r);
                        }
                    }
                }
                
                
                my $json = to_json(\@recs);
                my $description = $f->{'feed'}->{'title'}.' '.$sev.' severity '.$conf.'% confidence '.$r.' feed';
                my $impact = $f->{'feed'}->{'title'}.' feed';
                my $zcontent = encode_base64(compress($json));
                my ($err,$id) = CIF::Archive->insert({
                    source      => 'localhost',
                    data        => $zcontent,
                    hash_sha1   => sha1_hex($zcontent),
                    severity    => $sev,
                    confidence  => $conf,
                    description => lc($description),
                    impact      => lc($impact),
                    restriction => lc($r),
                    detecttime  => $dt,
                    format      => 'text/base64'
                });
                cleanup($err) unless($id);
                print lc($description).': '.$id.' created -- '.$id->uuid()."\n";
                my @feeds = CIF::Archive::DataType::Plugin::Feed->retrieve_from_sql(qq{
                    impact = '$impact'
                    AND severity = '$sev'
                    AND restriction = '$r'
                    AND confidence = '$conf'
                    ORDER BY id ASC
                });
                if($#feeds >= $last_feeds){
                    foreach (0 ... $last_feeds-1){
                        pop(@feeds);
                    }
                    foreach (@feeds){
                        print 'removing feed: '.$_->id().' -- '.$_->uuid->uuid()."\n";
                        eval {
                            CIF::Archive->retrieve(uuid => $_->uuid->uuid())->delete();
                        };
                        if($@){
                            warn $@;
                            remove_lock();
                            exit(-1);
                        }
                    }
                }
            }
        }
    }
    }
    ## TODO -- if $id is < than most recent feed (of this type), we need to re-insert this as a new feed (or delete the old feed)
    _profile('finished',$start);
}

remove_lock();
exit(0);

sub _debug {
    return unless($debug);
    my $msg = shift;
    my ($pkg,$f,$line) = caller();
    warn "[DEBUG] $line: $msg";
}

sub _profile {
    my ($msg,$start) = @_;
    _debug('('.(time() - $start).') '.$msg);
}
