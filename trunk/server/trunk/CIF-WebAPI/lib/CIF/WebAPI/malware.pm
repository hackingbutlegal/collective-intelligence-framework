package CIF::WebAPI::malware;
use base 'CIF::WebAPI';

use warnings;
use strict;

use CIF::Message::Malware;
use CIF::WebAPI::malware::malware;
use CIF::WebAPI::malware::cache;

sub mapIndex {
    my $r = shift;
    my $idx = CIF::WebAPI::mapIndex($r);
    delete($idx->{'rec'});

    return {
        %$idx,
        hash_sha1   => $r->hash_sha1(),
        hash_md5    => $r->hash_md5(),
    };
}

sub aggregateFeed {
    my @recs = @_;

    my @res = @{CIF::WebAPI::aggregateFeed('hash_md5',@recs)};
    my @feed;
    foreach (@res){
        my $idx = mapIndex($_->{'rec'});
        delete($_->{'rec'});
        push(@feed,$idx);
    }
    return(@feed);
}

sub generateFeed {
    my $response = shift;
    my @recs = @_;

    my @feed = aggregateFeed(@recs);

    $response->data()->{'result'} = \@feed;
    return Apache2::Const::HTTP_OK;
}

sub GET {
    my ($self, $request, $response) = @_;

    my $detecttime = DateTime->from_epoch(epoch => (time() - (84600 * 30)));
    my @recs = CIF::Message::Malware->search_feed($detecttime,10000);
    return generateFeed($response,@recs);
}

sub buildNext {
    my ($self,$frag,$req) = @_;
    if(lc($frag) eq 'cache'){
        return CIF::WebAPI::malware::cache->new($self);
    }
    return undef unless(lc($frag) =~ /^[0-9a-f]{32,40}$/);
    my $subh = CIF::WebAPI::malware::malware->new($self);
    $subh->{'hashid'} = lc($frag);
    return $subh;
}

1;
