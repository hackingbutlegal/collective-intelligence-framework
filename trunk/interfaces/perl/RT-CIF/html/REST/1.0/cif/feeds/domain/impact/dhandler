<%ARGS>
$detecttime => undef
$qlimit    => 1500
$feedlimit  => 500
$format     => 'text'
</%ARGS>
<%INIT>
use RT::Interface::REST;
use CIF::Message::Domain;
use CIF::Message::DomainWhitelist;
use DateTime::Format::DateParse;

my $arg = lc($m->dhandler_arg());

my $output = '';
my $status = '200 Ok';

unless($detecttime){
    $detecttime = DateTime->from_epoch(epoch => (time() - (84600 * 30)));
}

my $sql = qq{
    detecttime >= '$detecttime' AND type != 'NS' AND lower(impact) LIKE '%$arg%'
    AND impact NOT LIKE '%passive dns%'
    AND impact NOT LIKE '%whitelist%'
    ORDER BY detecttime DESC, created DESC, id DESC
    LIMIT $qlimit
};

my @recs = CIF::Message::Domain->retrieve_from_sql($sql);

# extra whitelist processing since domains are tricky (eg: we want all of .google.com)
my @rrecs;
foreach (@recs){
    #next if(CIF::Message::DomainWhitelist->isWhitelisted($_->address()));
    push(@rrecs,$_);
}
@recs = @rrecs;

$status .= ' '.$#recs.'/'.$feedlimit.' (total recs / feed limit)';

my @feed;
my $x = 1;
my $hash;
foreach my $r (@recs){
    if(exists($hash->{$r->address()})){
        if($r->restriction eq 'need-to-know'){
            next unless($r->restriction() eq 'private');
        }
    }

    $hash->{$r->address()} = $r;
                      
    last if($x++ == $feedlimit);
}
foreach (keys %$hash){
    push(@feed,$hash->{$_});
}
@recs = @feed;

$output = eval { $m->comp('/REST/1.0/cif/feeds/domain/'.$format, recs => \@recs) };
if($@){
    $output = $m->comp('/REST/1.0/cif/feeds/domain/text', recs => \@recs);
}

$m->out("RT/". $RT::VERSION . " " . $status ."\n\n");
$m->out($output);
</%INIT>
